// Copyright 2024-2025 Michael Petersen. All rights reserved.
// Use of this source code is governed by an Apache license that can be found in the LICENSE file.

// Package elf defines constants and types for ELF (Executable and Linkable Format) directives used in assembly code generation.
// Note: ELF is part the System V ABI for x86_64 architecture and is used for linking and loading executable files.
package elf

// Header for all assembly code files generated by the PL/0 compiler.
const AssemblyCodeHeader = "# x86_64 assembly code\n# generated by PL/0 compiler\n\n.intel_syntax noprefix\n"

// Details of the text section, which contains the executable code.
const TextSectionDetails = textSectionDetails

// Assembler directives for the ELF format supported by various assemblers on Linux.
const (
	// symbol declaration directives
	Global DirectiveKind = iota // declares a global symbol visible to the linker (.globl <name>)
	Type                        // specifies the symbol type for ELF (.type <name>, @function/@object/...)
	Size                        // declares the size of a symbol in bytes (.size <name>, .-<name>)
	Weak                        // marks a symbol as weak; can be overridden (.weak <name>)
	Hidden                      // makes a symbol hidden from external linking (.hidden <name>)

	// section control directives
	Section // changes or creates a named section (.section <name>[, "flags", @type])
	Text    // switches to the .text (code) section (.text)
	Data    // switches to the .data (writable data) section (.data)
	Rodata  // switches to the .rodata (read-only data) section (.rodata)
	Bss     // switches to the .bss (zero-initialized data) section (.bss)

	// alignment and layout directives
	P2Align // aligns to 2^n bytes (.p2align <n>) — used for ABI alignment
	Align   // aligns to n bytes (.align <n>) — less portable across platforms
	Balign  // aligns using byte-boundary logic (.balign <n>) — same as .align but stricter in ELF

	// value emission directives
	Byte   // emits a single byte value (.byte 0xFF)
	Word   // emits a 16-bit word (.word 0xABCD)
	Long   // emits a 32-bit value (.long 0x12345678)
	Quad   // emits a 64-bit value (.quad 0xDEADBEEFCAFEBABE)
	Zero   // emits a run of zero bytes (.zero <count>)
	String // emits a null-terminated ASCII string (.string "text")
	Ascii  // emits an unterminated ASCII string (.ascii "text")

	// debug info and DWARF metadata
	File         // specifies the source file name for debug info (.file "source.c")
	Loc          // marks source location in debug info (.loc file line column)
	Line         // specifies source line number (legacy) (.line <n>)
	CfiStartProc // begins a CFI frame for a function (.cfi_startproc)
	CfiEndProc   // ends a CFI frame for a function (.cfi_endproc)
	CfiDefCfa    // defines call frame address rule (.cfi_def_cfa reg offset)
	CfiOffset    // defines register offset in CFI (.cfi_offset reg offset)
)

// Kind of read-only data to be stored in a read-only section.
const (
	ReadOnlyUtf32 ReadOnlyDataKind = iota // UTF-32 encoded strings
	ReadOnlyInt64                         // 64-bit integer literals (signed and unsigned)
)

type (
	// Represents the type of an assembler directive (pseudo-op).
	DirectiveKind int

	// Kind of read-only static data.
	ReadOnlyDataKind int

	// A read-only data item is a constant value that is not modified during program execution.
	ReadOnlyDataItem struct {
		Kind   ReadOnlyDataKind `json:"kind"`   // kind of the read-only data item
		Labels []string         `json:"labels"` // labels to access the read-only data item
		Value  any              `json:"value"`  // the value will be stored in a read-only section and encoded based on its kind
	}

	// Details of a read-only data item, including its section and alignment representation.
	ReadOnlyDataItemDetails struct {
		Section   string `json:"section"`   // section representation for the read-only data item
		Alignment string `json:"alignment"` // alignment representation for the read-only data item
	}
)

// Create a new read-only data item for a read-only section.
func NewReadOnlyDataItem(kind ReadOnlyDataKind, labels []string, value any) *ReadOnlyDataItem {
	return &ReadOnlyDataItem{Kind: kind, Labels: labels, Value: value}
}

// String representation of a directive kind.
func (dk DirectiveKind) String() string {
	return directiveKindNames[dk]
}

// Detail representation of a read-only data kind.
func (rdk ReadOnlyDataKind) Detail() ReadOnlyDataItemDetails {
	return readOnlyDataKindDetails[rdk]
}
