// Copyright 2024-2025 Michael Petersen. All rights reserved.
// Use of this source code is governed by an Apache license that can be found in the LICENSE file.

package x86_64

import (
	"encoding/json"
	"fmt"
	"io"
	"strings"

	cor "github.com/petersen65/PL0/v2/core"
	elf "github.com/petersen65/PL0/v2/emitter/elf"
)

// Header for all assembly code files generated by an external compiler driver.
const assemblyCodeHeader = "# %v assembly code\n# optimization %v\n# generated by %v\n\n"

type (
	// Represents a logical unit of assembly instructions created from one intermediate code unit.
	assemblyCodeUnit struct {
		Labels             []string                                        `json:"labels"`               // enable deterministic iteration over the symbol table in the order of past inserts
		SymbolTable        map[string]*Symbol                              `json:"symbol_table"`         // symbol table for assembly code label names
		FileIdentifier     map[string]int                                  `json:"file_identifier"`      // file identifier for source code files
		BuildConfiguration cor.BuildConfiguration                          `json:"build_configuration"`  // build configuration of the assembly code unit
		debugInformation   cor.DebugInformation                            `json:"-"`                    // debug information collected from earlier compilation phases
		RoUtf32Section     *elf.ElfSection[*elf.ReadOnlyDataItem]          `json:"utf32_section"`        // read-only data section for static UTF-32 strings
		RoInt64Section     *elf.ElfSection[*elf.ReadOnlyDataItem]          `json:"int64_section"`        // read-only data section for static 64-bit integers
		RoStrDescSection   *elf.ElfSection[*elf.ReadOnlyDataItem]          `json:"strdesc_section"`      // read-only data section for string descriptors
		TextSection        *elf.ElfSection[*Instruction]                   `json:"text_section"`         // text section with assembly instructions
		DebugAbbrevSection *elf.ElfSection[*elf.AbbreviationEntry]         `json:"debug_abbrev_section"` // DWARF section with abbreviation schema entries required by DIEs
		DebugInfoSection   *elf.ElfSection[*elf.DebuggingInformationEntry] `json:"debug_info_section"`   // DWARF section with debugging information entries (DIEs)
		DebugStrSection    *elf.ElfSection[*elf.StringItem]                `json:"debug_str_section"`    // DWARF section with string items referenced by DIEs
	}
)

var (
	// Map CPU operation codes to their string representation.
	operationNames = map[OperationCode]string{
		None:    "",
		Push:    "push",
		Pop:     "pop",
		Cmp:     "cmp",
		Test:    "test",
		Cld:     "cld",
		Rep:     "rep",
		Stosq:   "stosq",
		Mov:     "mov",
		MovAbs:  "movabs",
		Movsxd:  "movsxd",
		Movsx:   "movsx",
		Movzx:   "movzx",
		Lea:     "lea",
		Jmp:     "jmp",
		Je:      "je",
		Jne:     "jne",
		Jl:      "jl",
		Jle:     "jle",
		Jg:      "jg",
		Jge:     "jge",
		Jb:      "jb",
		Jbe:     "jbe",
		Ja:      "ja",
		Jae:     "jae",
		Neg:     "neg",
		And:     "and",
		Xor:     "xor",
		Cqo:     "cqo",
		Add:     "add",
		Sub:     "sub",
		Imul:    "imul",
		Div:     "div",
		Idiv:    "idiv",
		Call:    "call",
		Ret:     "ret",
		Ucomisd: "ucomisd",
		Ucomiss: "ucomiss",
		Movsd:   "movsd",
		Movss:   "movss",
		Movq:    "movq",
		Movd:    "movd",
		Xorpd:   "xorpd",
		Xorps:   "xorps",
		Addsd:   "addsd",
		Addss:   "addss",
		Subsd:   "subsd",
		Subss:   "subss",
		Mulsd:   "mulsd",
		Mulss:   "mulss",
		Divsd:   "divsd",
		Divss:   "divss",
	}

	// Map CPU registers to their string representation.
	registerNames = map[Register]string{
		Rax:   "rax",
		Rbx:   "rbx",
		Rcx:   "rcx",
		Rdx:   "rdx",
		Rsi:   "rsi",
		Rdi:   "rdi",
		R8:    "r8",
		R9:    "r9",
		R10:   "r10",
		R11:   "r11",
		R12:   "r12",
		R13:   "r13",
		R14:   "r14",
		R15:   "r15",
		Rip:   "rip",
		Rsp:   "rsp",
		Rbp:   "rbp",
		Eax:   "eax",
		Ebx:   "ebx",
		Ecx:   "ecx",
		Edx:   "edx",
		Esi:   "esi",
		Edi:   "edi",
		R8d:   "r8d",
		R9d:   "r9d",
		R10d:  "r10d",
		R11d:  "r11d",
		R12d:  "r12d",
		R13d:  "r13d",
		R14d:  "r14d",
		R15d:  "r15d",
		Ax:    "ax",
		Bx:    "bx",
		Cx:    "cx",
		Dx:    "dx",
		Si:    "si",
		Di:    "di",
		R8w:   "r8w",
		R9w:   "r9w",
		R10w:  "r10w",
		R11w:  "r11w",
		R12w:  "r12w",
		R13w:  "r13w",
		R14w:  "r14w",
		R15w:  "r15w",
		Al:    "al",
		Bl:    "bl",
		Cl:    "cl",
		Dl:    "dl",
		Ah:    "ah",
		Bh:    "bh",
		Ch:    "ch",
		Dh:    "dh",
		R8b:   "r8b",
		R9b:   "r9b",
		R10b:  "r10b",
		R11b:  "r11b",
		R12b:  "r12b",
		R13b:  "r13b",
		R14b:  "r14b",
		R15b:  "r15b",
		Xmm0:  "xmm0",
		Xmm1:  "xmm1",
		Xmm2:  "xmm2",
		Xmm3:  "xmm3",
		Xmm4:  "xmm4",
		Xmm5:  "xmm5",
		Xmm6:  "xmm6",
		Xmm7:  "xmm7",
		Xmm8:  "xmm8",
		Xmm9:  "xmm9",
		Xmm10: "xmm10",
		Xmm11: "xmm11",
		Xmm12: "xmm12",
		Xmm13: "xmm13",
		Xmm14: "xmm14",
		Xmm15: "xmm15",
	}

	// Map CPU operand sizes to their string representation.
	operandSizeNames = map[OperandSize]string{
		Bits8:  "byte",
		Bits16: "word",
		Bits32: "dword",
		Bits64: "qword",
	}
)

// Create a new assembly code unit with its sections and provide build and debug information.
func newAssemblyCodeUnit(buildConfiguration cor.BuildConfiguration, debugInformation cor.DebugInformation) AssemblyCodeUnit {
	unit := &assemblyCodeUnit{
		Labels:             make([]string, 0),
		SymbolTable:        make(map[string]*Symbol),
		FileIdentifier:     map[string]int{buildConfiguration.SourcePath: 1},
		BuildConfiguration: buildConfiguration,
		debugInformation:   debugInformation,

		// read-only data section for static UTF-32 strings
		RoUtf32Section: elf.NewSection[*elf.ReadOnlyDataItem](
			[]elf.DirectiveKind{elf.Section, elf.Utf32},
			[]elf.SectionAttribute{elf.SectionAllocatable, elf.SectionProgramBits},
			elf.P2align4,
			false),

		// read-only data section for static 64-bit integers (signed and unsigned)
		RoInt64Section: elf.NewSection[*elf.ReadOnlyDataItem](
			[]elf.DirectiveKind{elf.Section, elf.Int64},
			[]elf.SectionAttribute{elf.SectionAllocatable, elf.SectionProgramBits},
			elf.P2align8,
			false),

		// read-only data section for string descriptors (64-bit string addresses and lengths)
		RoStrDescSection: elf.NewSection[*elf.ReadOnlyDataItem](
			[]elf.DirectiveKind{elf.Section, elf.StrDesc},
			[]elf.SectionAttribute{elf.SectionAllocatable, elf.SectionProgramBits},
			elf.P2align8,
			false),

		// text section for all assembly instructions
		TextSection: elf.NewSection[*Instruction](
			[]elf.DirectiveKind{elf.Section, elf.Text},
			[]elf.SectionAttribute{},
			elf.P2align16,
			false),

		// DWARF debug abbreviation section with schema entries required by DIEs
		DebugAbbrevSection: elf.NewSection[*elf.AbbreviationEntry](
			[]elf.DirectiveKind{elf.Section, elf.DebugAbbrev},
			[]elf.SectionAttribute{elf.SectionNone, elf.SectionProgramBits},
			elf.P2align1,
			true,
		),

		// DWARF debug information section with debugging information entries (DIEs)
		DebugInfoSection: elf.NewSection[*elf.DebuggingInformationEntry](
			[]elf.DirectiveKind{elf.Section, elf.DebugInfo},
			[]elf.SectionAttribute{elf.SectionNone, elf.SectionProgramBits},
			elf.P2align1,
			true,
		),

		// DWARF debug strings section with string items referenced by DIEs
		DebugStrSection: elf.NewSection[*elf.StringItem](
			[]elf.DirectiveKind{elf.Section, elf.DebugStr},
			[]elf.SectionAttribute{elf.SectionMergeableStrings, elf.SectionProgramBits},
			elf.P2align1,
			true),
	}

	// define default global and external symbols based on the output kind
	switch buildConfiguration.OutputKind {
	case cor.Application:
		// global symbol for the entry point of the application
		unit.Insert(NewSymbol(
			[]string{
				cor.EntryPointLabel,
			},
			FunctionEntry,
			Global,
		))

		// external symbols for the runtime functions
		unit.Insert(NewSymbol(
			[]string{
				CreateStaticLinkLabel,
				FollowStaticLinkLabel,
			},
			FunctionEntry,
			External,
		))

	case cor.Runtime:
		// global symbols for runtime functions
		unit.Insert(NewSymbol(
			[]string{
				CreateStaticLinkLabel,
				FollowStaticLinkLabel,
			},
			FunctionEntry,
			Global,
		))

	default:
		panic(cor.NewGeneralError(cor.Intel, failureMap, cor.Fatal, unknownOutputKind, buildConfiguration.OutputKind, nil))
	}

	return unit
}

// Create a new memory operand for an assembly instruction.
func newMemoryOperand(register Register, size OperandSize, displacements ...any) *Operand {
	// default memory operand with no symbol and no offset displacements
	operand := &Operand{
		Kind:     MemoryOperand,
		Register: register,
		Memory:   MemoryDetail{Size: size, Symbol: "", Offset: 0},
	}

	// set the displacement symbol and offset if they have a supported data type
	for _, displacement := range displacements {
		if displacement != nil {
			switch d := displacement.(type) {
			case string:
				operand.Memory.Symbol = d

			case int:
				operand.Memory.Offset = int32(d)

			case int32:
				operand.Memory.Offset = d

			default:
				panic(cor.NewGeneralError(cor.Intel, failureMap, cor.Fatal, illegalDisplacementInMemoryOperand, displacement, nil))
			}
		}
	}

	return operand
}

// Fluently append a new assembler directive to an instruction.
func (i *Instruction) AppendDirective(directive *elf.Directive) *Instruction {
	if directive != nil {
		i.Directives = append(i.Directives, directive)
	}

	return i
}

// String representation of an operand kind of CPU operations.
func (o *Operand) String() string {
	switch o.Kind {
	case RegisterOperand:
		return o.Register.String()

	case ImmediateOperand:
		return fmt.Sprintf("%v", o.Immediate)

	case MemoryOperand:
		switch {
		case o.Memory.Offset != 0 && o.Memory.Symbol == "":
			return fmt.Sprintf("%v ptr [%v%+d]", o.Memory.Size, o.Register, o.Memory.Offset)

		case o.Memory.Offset == 0 && o.Memory.Symbol != "":
			return fmt.Sprintf("%v ptr [%v+%v]", o.Memory.Size, o.Register, o.Memory.Symbol)

		case o.Memory.Offset != 0 && o.Memory.Symbol != "":
			return fmt.Sprintf("%v ptr [%v+%v%+d]", o.Memory.Size, o.Register, o.Memory.Symbol, o.Memory.Offset)

		default:
			return fmt.Sprintf("%v ptr [%v]", o.Memory.Size, o.Register)
		}

	case LabelOperand:
		return o.Label

	default:
		panic(cor.NewGeneralError(cor.Intel, failureMap, cor.Fatal, unknownKindOfOperandInCpuOperation, o.Kind, nil))
	}
}

// String representation of an assembly instruction.
func (i *Instruction) String() string {
	const prefixOperationWidth = 12
	var builder strings.Builder

	// write specific assembler directives before instruction labels, if any
	for _, directive := range i.Directives {
		switch directive.Directive {
		case elf.Type:
			builder.WriteString(fmt.Sprintf("%v\n", directive))
		}
	}

	// write the branch target labels for the instruction, if any
	for _, label := range i.Labels {
		builder.WriteString(fmt.Sprintf("%v:\n", label))
	}

	// write specific assembler directives after instruction labels but before the instruction, if any
	for _, directive := range i.Directives {
		switch directive.Directive {
		case elf.Loc, elf.CfiStartProc, elf.CfiDefCfaOffset, elf.CfiOffset:
			builder.WriteString(fmt.Sprintf("%v\n", directive))
		}
	}

	// write the prefix and operation code
	builder.WriteString(fmt.Sprintf(
		"%v%-*v", elf.DefaultIndentation, prefixOperationWidth,
		strings.TrimSpace(fmt.Sprintf("%v %v", i.Prefix, i.Operation))))

	// write the operands
	if len(i.Operands) > 0 {
		operands := make([]string, len(i.Operands))

		// convert each operand to its string representation
		for i, op := range i.Operands {
			operands[i] = op.String()
		}

		builder.WriteString(strings.Join(operands, ", "))
	}

	// write specific assembler directives after the instruction, if any
	for _, directive := range i.Directives {
		switch directive.Directive {
		case elf.Size, elf.CfiEndProc, elf.CfiDefCfaRegister:
			builder.WriteString(fmt.Sprintf("\n%v", directive))
		}
	}

	return builder.String()
}

// Append an instruction with branch target labels to the assembly code unit.
func (u *assemblyCodeUnit) AppendInstruction(operation OperationCode, labels []string, tokenStreamIndex int, operands ...*Operand) *Instruction {
	instruction := NewInstruction(operation, labels, tokenStreamIndex, operands...)
	u.TextSection.Append(instruction)
	return instruction
}

// Append a prefixed instruction with branch target labels to the assembly code unit.
func (u *assemblyCodeUnit) AppendPrefixedInstruction(prefix, operation OperationCode, labels []string, tokenStreamIndex int, operands ...*Operand) *Instruction {
	instruction := NewPrefixedInstruction(prefix, operation, labels, tokenStreamIndex, operands...)
	u.TextSection.Append(instruction)
	return instruction
}

// Append a read-only data item with literal data labels to the assembly code unit.
func (u *assemblyCodeUnit) AppendReadOnlyDataItem(kind elf.ReadOnlyDataKind, labels []string, values any) {
	switch kind {
	case elf.ReadOnlyUtf32:
		u.RoUtf32Section.Append(elf.NewReadOnlyDataItem(kind, labels, values))

	case elf.ReadOnlyInt64:
		u.RoInt64Section.Append(elf.NewReadOnlyDataItem(kind, labels, values))

	case elf.ReadOnlyStrDesc:
		u.RoStrDescSection.Append(elf.NewReadOnlyDataItem(kind, labels, values))

	default:
		panic(cor.NewGeneralError(cor.Intel, failureMap, cor.Fatal, unknownKindOfReadOnlyData, kind, nil))
	}
}

// Append an existing instruction to the assembly code unit.
func (u *assemblyCodeUnit) AppendExistingInstruction(instruction *Instruction) {
	u.TextSection.Append(instruction)
}

// Append an existing read-only data item to the assembly code unit.
func (u *assemblyCodeUnit) AppendExistingReadOnlyDataItem(item *elf.ReadOnlyDataItem) {
	switch item.Kind {
	case elf.ReadOnlyUtf32:
		u.RoUtf32Section.Append(item)

	case elf.ReadOnlyInt64:
		u.RoInt64Section.Append(item)

	case elf.ReadOnlyStrDesc:
		u.RoStrDescSection.Append(item)

	default:
		panic(cor.NewGeneralError(cor.Intel, failureMap, cor.Fatal, unknownKindOfReadOnlyData, item.Kind, nil))
	}
}

// Append a set of instructions to create all runtime functions.
func (u *assemblyCodeUnit) AppendRuntime() {
	if u.HasDebugInformation() {
		panic(cor.NewGeneralError(cor.Intel, failureMap, cor.Fatal, optimizationDebugNotSupportedinRuntime, u.BuildConfiguration.Optimization, nil))
	}

	loopCondition := fmt.Sprintf("%v.1", FollowStaticLinkLabel)
	behindLoop := fmt.Sprintf("%v.2", FollowStaticLinkLabel)
	noIndex := cor.NoTokenStreamIndex

	/*
		# -------------------------------------------------------------------------------
		# rt.create_static_link
		#
		# Purpose:
		#   Computes and stores the static link for a newly entered procedure.
		#
		# Assumptions:
		#   - r10d contains the lexical depth difference between the caller and callee.
		#     (e.g., 0 = immediate parent, 1 = skip one static scope, etc.)
		#   - The current stack frame is fully set up:
		#       - rbp points to the current frame (callee's frame).
		#       - [rbp] contains the saved rbp of the caller (dynamic link).
		#
		# Effects:
		#   - Calls follow_static_link to resolve the static parent.
		#   - Stores the resolved static link (frame pointer of parent scope) at [rbp-8].
		#     This is assumed to be the callee’s first local variable (invisible to ABI).
		#
		# Clobbers:
		#   - rax, rsi (internally used)
		#   - r10d remains unchanged (caller-saved)
		#
		# Details:
		#   - The static link is a pointer to the frame of a lexical parent.
		#   - The dynamic link is a pointer to the frame of the actual caller.
		#   - They are equal only when: the caller is the immediate parent of the callee.
		#   - r10d == 0 is not just a numerical fact, but a semantic assertion.
		# -------------------------------------------------------------------------------
		rt.create_static_link:
			mov         edi, r10d                    # move depth difference into edi (used as counter)
			mov         rsi, qword ptr [rbp]         # load caller's rbp (dynamic link) into rsi
			call        rt.follow_static_link.1      # follow static link chain depth times
			mov         qword ptr [rbp-8], rax       # store static link (resolved frame pointer) into callee’s locals
			ret
	*/
	mov := NewInstruction(Mov, []string{CreateStaticLinkLabel}, noIndex, NewRegisterOperand(Edi), NewRegisterOperand(R10d))
	mov.AppendDirective(elf.NewTypeFunction(CreateStaticLinkLabel))
	u.AppendExistingInstruction(mov)
	u.AppendInstruction(Mov, nil, noIndex, NewRegisterOperand(Rsi), NewMemoryOperand(Rbp, Bits64, 0))
	u.AppendInstruction(Call, nil, noIndex, NewLabelOperand(loopCondition))
	u.AppendInstruction(Mov, nil, noIndex, NewMemoryOperand(Rbp, Bits64, -PointerSize), NewRegisterOperand(Rax))
	ret := NewInstruction(Ret, nil, noIndex)
	ret.AppendDirective(elf.NewSizeLabel(CreateStaticLinkLabel))
	u.AppendExistingInstruction(ret)

	/*
		# -------------------------------------------------------------------------------
		# rt.follow_static_link
		#
		# Purpose:
		#   Entry point for static link traversal.
		#
		# Effects:
		#   - Sets rsi = rbp (if needed for manual entry)
		#   - Falls through into rt.follow_static_link.1
		# -------------------------------------------------------------------------------
		rt.follow_static_link:
			mov         rsi, rbp                     # optional manual starting point for static link chain
													 # used if follow_static_link is called with current rbp
	*/
	mov = NewInstruction(Mov, []string{FollowStaticLinkLabel}, noIndex, NewRegisterOperand(Rsi), NewRegisterOperand(Rbp))
	mov.AppendDirective(elf.NewTypeFunction(FollowStaticLinkLabel))
	u.AppendExistingInstruction(mov)

	/*
		# -------------------------------------------------------------------------------
		# rt.follow_static_link.1
		#
		# Purpose:
		#   Recursively follows the static link chain `edi` times.
		#
		# Assumptions:
		#   - edi = depth difference (0 means: current level)
		#   - rsi = starting frame pointer
		#
		# Result:
		#   - rax = frame pointer of the statically enclosing scope
		#
		# Clobbers:
		#   - rsi, edi
		# -------------------------------------------------------------------------------
		rt.follow_static_link.1:
			cmp         edi, 0                       # have we reached the target lexical depth (difference == 0)?
			je          rt.follow_static_link.2      # yes → stop and return current frame pointer in rsi
			mov   		rdx, qword ptr [rsi-8]		 # load the next static link from current frame
			test  		rdx, rdx					 # check if the next static link is 0 (end of static link chain)
			je    		rt.follow_static_link.2      # if 0 → stop to avoid entering external frames (e.g., C runtime)
			mov         rsi, qword ptr [rsi-8]       # follow the static link upward (i.e., to lexical parent frame)
			sub         edi, 1                       # decrease remaining lexical distance
			jmp         rt.follow_static_link.1      # repeat loop until depth is 0 or static link chain ends

		rt.follow_static_link.2:
			mov         rax, rsi                     # return the resolved static link (frame pointer of target lexical parent)
			ret 									 # return to caller with rax = static link result
	*/
	u.AppendInstruction(Cmp, []string{loopCondition}, noIndex, NewRegisterOperand(Edi), NewImmediateOperand(int32(0)))
	u.AppendInstruction(Je, nil, noIndex, NewLabelOperand(behindLoop))
	u.AppendInstruction(Mov, nil, noIndex, NewRegisterOperand(Rdx), NewMemoryOperand(Rsi, Bits64, -PointerSize))
	u.AppendInstruction(Test, nil, noIndex, NewRegisterOperand(Rdx), NewRegisterOperand(Rdx))
	u.AppendInstruction(Je, nil, noIndex, NewLabelOperand(behindLoop))
	u.AppendInstruction(Mov, nil, noIndex, NewRegisterOperand(Rsi), NewRegisterOperand(Rdx))
	u.AppendInstruction(Sub, nil, noIndex, NewRegisterOperand(Edi), NewImmediateOperand(int32(1)))
	u.AppendInstruction(Jmp, nil, noIndex, NewLabelOperand(loopCondition))
	u.AppendInstruction(Mov, []string{behindLoop}, noIndex, NewRegisterOperand(Rax), NewRegisterOperand(Rsi))
	ret = NewInstruction(Ret, nil, noIndex)
	ret.AppendDirective(elf.NewSizeLabel(FollowStaticLinkLabel))
	u.AppendExistingInstruction(ret)
}

// Insert a symbol into the assembly code symbol table. If the symbol already exists, it will be overwritten.
func (u *assemblyCodeUnit) Insert(symbol *Symbol) {
	for _, label := range symbol.Labels {
		if u.Lookup(label) == nil {
			u.Labels = append(u.Labels, label)
		}

		u.SymbolTable[label] = symbol
	}
}

// Lookup a symbol in the the assembly code symbol table. If the symbol is not found, nil is returned.
func (u *assemblyCodeUnit) Lookup(label string) *Symbol {
	if symbol, ok := u.SymbolTable[label]; ok {
		return symbol
	}

	return nil
}

// Get the location directive for a specific token stream index of the source code file. Nil is returned if no directive is available.
func (u *assemblyCodeUnit) Location(index int, debugger elf.Debugger, attributes ...string) *elf.Directive {
	// extract file identifier and debug flag required for the location directive
	id := u.FileIdentifier[u.BuildConfiguration.SourcePath]

	// if source code files cannot be supported by the assembly code unit return nil
	if index == cor.NoTokenStreamIndex || u.debugInformation == nil || !u.HasDebugInformation() || id == 0 {
		return nil
	}

	// if debug information is available, create a location directive with the source code context
	if line, column, currentLine, ok := u.debugInformation.GetSourceCodeContext(index); ok {
		loc := elf.NewLocation(id, line, column, debugger, attributes...)
		loc.AppendComment(currentLine)
		return loc
	}

	// if no source code context is available, return nil
	return nil
}

// Filter the directive based on the build configuration and return nil if it should not be included in the assembly code.
func (u *assemblyCodeUnit) Filter(directive *elf.Directive) *elf.Directive {
	if u.HasDebugInformation() {
		return directive
	}

	return nil
}

// Check whether the assembly code unit is configured with debug information.
func (u *assemblyCodeUnit) HasDebugInformation() bool {
	return u.BuildConfiguration.Optimization&cor.Debug != 0 && u.debugInformation != nil
}

// Print the assembly code to the specified writer and optionally accept global symbols as arguments.
func (u *assemblyCodeUnit) Print(print io.Writer, args ...any) error {
	var globals, externals []string

	// create the assembly code header with build configuration details
	header := fmt.Sprintf(assemblyCodeHeader,
		u.BuildConfiguration.TargetPlatform,
		u.BuildConfiguration.Optimization,
		u.BuildConfiguration.DriverDisplayName)

	// add the Intel syntax directive to the header
	header += elf.NewIntel(elf.IntelNoPrefix).String() + "\n"

	// enumerate all symbols in the assembly code unit and create global and external directives from them
	for _, label := range u.Labels {
		symbol := u.SymbolTable[label]

		// if the symbol is global, add it to the global symbols list
		if symbol.Flags == Global {
			globals = append(globals, label)
		}

		// if the symbol is an external reference, add it to the externals list
		if symbol.Flags == External {
			externals = append(externals, label)
		}
	}

	// if there are global symbols, add them to the header so that they can be linked with other object files
	if len(globals) > 0 {
		header += elf.NewGlobal(globals).String() + "\n"
	}

	// if there are external symbols, add them to the header as documentation and for linking purposes
	if len(externals) > 0 {
		header += elf.NewExtern(externals).String() + "\n"
	}

	// add the file directive with file identifier and name to the header if debug information is available
	if u.HasDebugInformation() {
		name := u.BuildConfiguration.SourcePath
		id := u.FileIdentifier[name]

		if name != "" && id > 0 {
			header += elf.NewFile(id, name).String() + "\n"
		} else {
			inner := cor.NewGoError(failureMap, invalidAttributeForDirective, elf.NewFile(id, name).String())
			return cor.NewGeneralError(cor.Intel, failureMap, cor.Error, assemblyCodeExportFailed, name, inner)
		}
	}

	// write the assembly code header to the print writer
	if _, err := fmt.Fprint(print, header); err != nil {
		return cor.NewGeneralError(cor.Intel, failureMap, cor.Error, assemblyCodeExportFailed, nil, err)
	}

	// write the read-only UTF-32 strings data section to the print writer
	if len(u.RoUtf32Section.Content) > 0 {
		if _, err := fmt.Fprintf(print, "%v\n", u.RoUtf32Section); err != nil {
			return cor.NewGeneralError(cor.Intel, failureMap, cor.Error, assemblyCodeExportFailed, nil, err)
		}
	}

	// write the read-only 64-bit integer data section to the print writer
	if len(u.RoInt64Section.Content) > 0 {
		if _, err := fmt.Fprintf(print, "%v\n", u.RoInt64Section); err != nil {
			return cor.NewGeneralError(cor.Intel, failureMap, cor.Error, assemblyCodeExportFailed, nil, err)
		}
	}

	// write the read-only string descriptor data section to the print writer
	if len(u.RoStrDescSection.Content) > 0 {
		if _, err := fmt.Fprintf(print, "%v\n", u.RoStrDescSection); err != nil {
			return cor.NewGeneralError(cor.Intel, failureMap, cor.Error, assemblyCodeExportFailed, nil, err)
		}
	}

	// write the text section to the print writer
	if len(u.TextSection.Content) > 0 {
		if _, err := fmt.Fprintf(print, "%v\n", u.TextSection); err != nil {
			return cor.NewGeneralError(cor.Intel, failureMap, cor.Error, assemblyCodeExportFailed, nil, err)
		}
	}

	// if debug information is enabled, update the .debug_abbrev, .debug_info, and .debug_str sections
	if u.HasDebugInformation() {
		// get the debug string table from the debug information and use it to populate the .debug_info and .debug_str sections
		dstab := u.debugInformation.GetDebugStringTable()

		// update the .debug_abbrev section with abbreviation entry schemas required for the .debug_info section
		if len(u.DebugAbbrevSection.Content) == 0 {
			updateDebugAbbrevSection(u.DebugAbbrevSection)
		}

		// update the .debug_info section with debugging information entries (DIEs) that reference the .debug_str section
		if len(u.DebugInfoSection.Content) == 0 {
			updateDebugInfoSection(u.DebugInfoSection, &dstab)
		}

		// update the .debug_str section with string items referenced by DIEs in the .debug_info section
		if len(u.DebugStrSection.Content) == 0 {
			updateDebugStrSection(u.DebugStrSection, &dstab)
		}

		// write the DWARF debug abbreviation section to the print writer
		if _, err := fmt.Fprintf(print, "%v\n", u.DebugAbbrevSection); err != nil {
			return cor.NewGeneralError(cor.Intel, failureMap, cor.Error, assemblyCodeExportFailed, nil, err)
		}

		// write the DWARF debug information section to the print writer
		if _, err := fmt.Fprintf(print, "%v\n", u.DebugInfoSection); err != nil {
			return cor.NewGeneralError(cor.Intel, failureMap, cor.Error, assemblyCodeExportFailed, nil, err)
		}

		// write the DWARF debug strings section to the print writer
		if _, err := fmt.Fprintf(print, "%v\n", u.DebugStrSection); err != nil {
			return cor.NewGeneralError(cor.Intel, failureMap, cor.Error, assemblyCodeExportFailed, nil, err)
		}
	}

	return nil
}

// Export the assembly code unit to the specified writer in the specified format.
func (u *assemblyCodeUnit) Export(format cor.ExportFormat, print io.Writer) error {
	// JSON formatting requires a prefix and indent for pretty printing
	const prefix, indent = "", "  "

	switch format {
	case cor.Json:
		// export the assembly code unit as a JSON object
		if raw, err := json.MarshalIndent(u, prefix, indent); err != nil {
			return cor.NewGeneralError(cor.Intel, failureMap, cor.Error, assemblyCodeExportFailed, nil, err)
		} else {
			_, err = print.Write(raw)

			if err != nil {
				err = cor.NewGeneralError(cor.Intel, failureMap, cor.Error, assemblyCodeExportFailed, nil, err)
			}

			return err
		}

	case cor.Text:
		// print is a convenience function to export the assembly code unit as a string to the print writer
		return u.Print(print)

	default:
		panic(cor.NewGeneralError(cor.Intel, failureMap, cor.Fatal, unknownExportFormat, format, nil))
	}
}

// Update the .debug_abbrev section with abbreviation schema entries required by DIEs in the .debug_info section.
func updateDebugAbbrevSection(debugAbbrevSection *elf.ElfSection[*elf.AbbreviationEntry]) {
	// compilation unit abbreviation entry
	compilationUnit := elf.NewAbbreviationEntry(
		elf.DW_CODE_compilation_unit,
		elf.DW_TAG_compile_unit,
		true,
		[]*elf.AttributeForm{
			elf.NewAttributeForm(elf.DW_AT_name, elf.DW_FORM_strp),            // source file name
			elf.NewAttributeForm(elf.DW_AT_comp_dir, elf.DW_FORM_strp),        // compilation directory
			elf.NewAttributeForm(elf.DW_AT_language, elf.DW_FORM_data2),       // source language
			elf.NewAttributeForm(elf.DW_AT_stmt_list, elf.DW_FORM_sec_offset), // line table offset
			elf.NewAttributeForm(elf.DW_AT_producer, elf.DW_FORM_strp),        // compiler name and version
		})

	// base type abbreviation entry
	baseType := elf.NewAbbreviationEntry(
		elf.DW_CODE_base_type,
		elf.DW_TAG_base_type,
		false,
		[]*elf.AttributeForm{
			elf.NewAttributeForm(elf.DW_AT_name, elf.DW_FORM_strp),       // type name
			elf.NewAttributeForm(elf.DW_AT_byte_size, elf.DW_FORM_data1), // byte size
			elf.NewAttributeForm(elf.DW_AT_encoding, elf.DW_FORM_data1),  // encoding
		},
	)

	// subprogram abbreviation entry
	subprogram := elf.NewAbbreviationEntry(
		elf.DW_CODE_subprogram,
		elf.DW_TAG_subprogram,
		true,
		[]*elf.AttributeForm{
			elf.NewAttributeForm(elf.DW_AT_name, elf.DW_FORM_strp),          // function name
			elf.NewAttributeForm(elf.DW_AT_linkage_name, elf.DW_FORM_strp),  // linkage name (mangled)
			elf.NewAttributeForm(elf.DW_AT_decl_file, elf.DW_FORM_data1),    // source file index
			elf.NewAttributeForm(elf.DW_AT_decl_line, elf.DW_FORM_data2),    // line in source file
			elf.NewAttributeForm(elf.DW_AT_low_pc, elf.DW_FORM_addr),        // start address
			elf.NewAttributeForm(elf.DW_AT_high_pc, elf.DW_FORM_data4),      // length as 4-byte offset
			elf.NewAttributeForm(elf.DW_AT_frame_base, elf.DW_FORM_exprloc), // typically DW_OP_call_frame_cfa
			elf.NewAttributeForm(elf.DW_AT_prototyped, elf.DW_FORM_flag),    // prototype used (always true for C23)
			elf.NewAttributeForm(elf.DW_AT_external, elf.DW_FORM_flag),      // externally visible (global or local)
		},
	)

	// variable abbreviation entry
	variable := elf.NewAbbreviationEntry(
		elf.DW_CODE_variable,
		elf.DW_TAG_variable,
		false,
		[]*elf.AttributeForm{
			elf.NewAttributeForm(elf.DW_AT_name, elf.DW_FORM_strp),        // name of the variable
			elf.NewAttributeForm(elf.DW_AT_decl_file, elf.DW_FORM_data1),  // source file index
			elf.NewAttributeForm(elf.DW_AT_decl_line, elf.DW_FORM_data2),  // line in source file
			elf.NewAttributeForm(elf.DW_AT_type, elf.DW_FORM_ref4),        // data type reference
			elf.NewAttributeForm(elf.DW_AT_location, elf.DW_FORM_exprloc), // expression that computes the variable’s address
		},
	)

	// the termination abbreviation entry is used to mark the end of abbreviation entries in the .debug_abbrev section
	termination := elf.NewAbbreviationEntry(elf.DW_CODE_termination, 0, false, nil)

	// add all entries to the .debug_abbrev section
	debugAbbrevSection.Append(compilationUnit)
	debugAbbrevSection.Append(baseType)
	debugAbbrevSection.Append(subprogram)
	debugAbbrevSection.Append(variable)
	debugAbbrevSection.Append(termination)
}

// Update the .debug_info section with debugging information entries (DIEs).
func updateDebugInfoSection(debugInfoSection *elf.ElfSection[*elf.DebuggingInformationEntry], dstab *cor.DebugStringTable) {
	// compilation unit header entry
	compilationUnitHeader := elf.NewDebuggingInformationEntry(
		elf.DW_CODE_suppression,
		[]*elf.AttributeItem{
			elf.NewAttributeItem(elf.Long, elf.ToSectionLength(elf.DebugInfo.EndLabel(), elf.DebugInfo.StartLabel())),
			elf.NewAttributeItem(elf.Short, uint16(elf.DwarfVersion)),
			elf.NewAttributeItem(elf.Byte, uint8(elf.DW_UT_compile)),
			elf.NewAttributeItem(elf.Byte, uint8(PointerSize)),
			elf.NewAttributeItem(elf.Long, elf.DebugAbbrev.ToSectionLabel()),
		},
	)

	// compilation unit entry
	compilationUnit := elf.NewDebuggingInformationEntry(
		elf.DW_CODE_compilation_unit,
		[]*elf.AttributeItem{
			elf.NewAttributeItem(elf.Long, elf.ToStringItemLabel(elf.CompilationUnitLabel)),
			elf.NewAttributeItem(elf.Long, elf.ToStringItemLabel(elf.CompilationDirectoryLabel)),
			elf.NewAttributeItem(elf.Short, uint16(elf.DW_LANG_C23)),
			elf.NewAttributeItem(elf.Long, elf.DebugLine.String()),
			elf.NewAttributeItem(elf.Long, elf.ToStringItemLabel(elf.ProducerLabel)),
		},
	)

	// base types entries
	basetypes := make([]*elf.DebuggingInformationEntry, 0)

	for _, dtd := range dstab.DataTypes {
		basetypes = append(basetypes, elf.NewDebuggingInformationEntry(
			elf.DW_CODE_base_type,
			[]*elf.AttributeItem{
				elf.NewAttributeItem(elf.Long, elf.ToStringItemLabel(dtd.NameSource)),
				elf.NewAttributeItem(elf.Byte, uint8(dtd.Size)),
				elf.NewAttributeItem(elf.Byte, uint8(5)),
			},
		))
	}

	// add compilation unit entries to the .debug_info section
	debugInfoSection.Append(compilationUnitHeader)
	debugInfoSection.Append(compilationUnit)

	// add all base type entries to the .debug_info section
	for _, die := range basetypes {
		debugInfoSection.Append(die)
	}
}

// Update the .debug_str section with string items referenced by DIEs in the .debug_info section.
func updateDebugStrSection(debugStrSection *elf.ElfSection[*elf.StringItem], dstab *cor.DebugStringTable) {
	// compilation details and producer are required for the .debug_str section
	if len(dstab.CompilationUnit) == 0 || len(dstab.CompilationDirectory) == 0 || len(dstab.Producer) == 0 {
		panic(cor.NewGeneralError(cor.Intel, failureMap, cor.Fatal, compilationDetailsAndProducerRequired, nil, nil))
	}

	// add the compilation details and producer to the debug string section
	debugStrSection.Append(elf.NewStringItem(elf.CompilationUnitLabel, elf.String, dstab.CompilationUnit))
	debugStrSection.Append(elf.NewStringItem(elf.CompilationDirectoryLabel, elf.String, dstab.CompilationDirectory))
	debugStrSection.Append(elf.NewStringItem(elf.ProducerLabel, elf.String, dstab.Producer))

	// deduplicate function, variable, and data type names ensuring unique label names in the .debug_str section
	labels := make(map[string]bool)

	// iterate over all unique function names
	for _, fd := range dstab.Functions {
		// ensure that the function name is a unique label name in the .debug_str section
		if ok, exists := labels[fd.NameSource]; ok && exists {
			continue
		}

		// mark the function name as used
		labels[fd.NameSource] = true

		// add the function name to the .debug_str section
		debugStrSection.Append(elf.NewStringItem(fd.NameSource, elf.String, fd.NameSource))
	}

	// iterate over all unique variable names
	for _, vd := range dstab.Variables {
		// ensure that the variable name is a unique label name in the .debug_str section
		if ok, exists := labels[vd.NameSource]; ok && exists {
			continue
		}

		// mark the variable name as used
		labels[vd.NameSource] = true

		// add the variable name to the .debug_str section
		debugStrSection.Append(elf.NewStringItem(vd.NameSource, elf.String, vd.NameSource))
	}

	// iterate over all unique data type names
	for _, dtd := range dstab.DataTypes {
		// ensure that the data type name is a unique label name in the .debug_str section
		if ok, exists := labels[dtd.NameSource]; ok && exists {
			continue
		}

		// mark the data type name as used
		labels[dtd.NameSource] = true

		// add the data type name to the .debug_str section
		debugStrSection.Append(elf.NewStringItem(dtd.NameSource, elf.String, dtd.NameSource))
	}
}
